<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>maven教学资料</title>
      <link href="/xfrl/2021/06/15/Maven/"/>
      <url>/xfrl/2021/06/15/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="maven教学资料"><a href="#maven教学资料" class="headerlink" title="maven教学资料"></a>maven教学资料</h1><h2 id="一、项目构建"><a href="#一、项目构建" class="headerlink" title="一、项目构建"></a>一、项目构建</h2><blockquote><p>给你一套源代码，你怎么能跑起来？</p></blockquote><ul><li><p>不能把！就是几个文件夹，几个文件。是不能运行的！</p></li><li><p>是不是需要和idea打交道，告诉idea怎么样才能运行起来，比如知道main方法在哪里？配置文件在哪里，编译好的文件输出到哪里，是不是？当然eclipse也一样。</p></li></ul><blockquote><p>平时我们是怎么构建项目的，项目怎么运行起来呢？</p></blockquote><ul><li>idea帮我们编译</li><li>我们依靠点击构建项目</li><li>一切设置好以后，使用工具（idea）帮我们打包</li></ul><blockquote><p>项目构建中几个关键点?</p></blockquote><ul><li>1、jdk啥版本</li><li>2、哪些文件夹是干啥的！！ 源文件？配置文件？测试文件？在哪里？</li><li>3、如果是web工程，web.xml放哪里？</li><li>4、编译文件，编译后的文件放在哪里。</li><li>5、打包，打包成什么文件</li></ul><h3 id="1、先聊一聊idea的项目结构"><a href="#1、先聊一聊idea的项目结构" class="headerlink" title="1、先聊一聊idea的项目结构"></a>1、先聊一聊idea的项目结构</h3><blockquote><p>好好说说Project Structure</p></blockquote><ul><li>英 /ˈstrʌktʃə(r)/<br>“ 项目结构”对话框允许您管理项目和IDE级别的元素，例如Modules，Facets，Libraries， Artifacts和SDK</li></ul><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/193906/12/8169/41009/60c85164Efe97ea14/1492b6e2dc2ccb11.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><blockquote><p>打开方式有两种</p></blockquote><p>1、通过工具栏</p><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/194272/25/8231/14726/60c85198Ee4dde897/5617f11371f36d18.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><p>2、通过快捷键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+Alt+S</span><br></pre></td></tr></table></figure><h4 id="（1）Project选项"><a href="#（1）Project选项" class="headerlink" title="（1）Project选项"></a>（1）Project选项</h4><p>指定项目名称，SDK，语言级别和编译器输出路径。</p><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/175847/32/14327/91596/60c8522aE2e6d7e1e/ce0130164bb867c6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><ul><li>Project name：项目名，使用此字段编辑项目名称。</li><li>Project SDK：项目SDK，选择项目SDK。如果所需SDK不在列表中，请单击“ New”，然后选择所需<br>的SDK类型。然后，在打开的对话框中，选择SDK主目录，然后单击确定。要查看或编辑所选SDK<br>的名称和内容，请单击”Edit”。（SDK页面将打开。）</li><li>Project language level：选择要支持的Java语言级别。选定的级别将被用作项目默认值。</li><li>Project compiler output：项目编译器输出，指定IntelliJ IDEA将存储编译结果的路径。单击选择<br>路径对话框中browseButton 的目录。</li><li>指定目录中的两个子目录将被创建：</li><li>production为生产代码。</li><li>test为测试来源。</li><li>在这些子目录中，将为每个模块创建单独的输出目录。输出路径可以在模块级重新定义。</li></ul><h4 id="（2）Modules-选项"><a href="#（2）Modules-选项" class="headerlink" title="（2）Modules 选项"></a>（2）Modules 选项</h4><p>指定项目名称，SDK，语言级别和编译器输出路径。</p><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/189287/23/8371/70360/60c852a9Ef0ee39e3/3be8097c19b8e6ad.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><ul><li><p>Name：项目名称</p></li><li><p>Souces：这里对Module的开发目录进行文件夹分类，就是说这个module里有什么内容，说明了<br>不同性质的内容放在哪里。</p><p>  注意，这些不同内容的标记代表了一个标准Java工程的各项内容，IntelliJ就是根据这些标记来识别<br>  一个Java工程的各项内容的，比如，它会用javac去编译标记为Sources的源码，打包的时候会把标<br>  记为Resources的资源拷贝到jar包中，并且忽略标记为Exluded的内容。左边显示的是在选中内容<br>  的预览。</p></li><li><p>Paths：为模块配置编译器输出路径，还可以指定与模块关联的外部JavaDocs和外部注释的位置。</p></li><li><p>Dependencies：在此选项卡上，您可以定义模块SDK并形成模块依赖关系列表。</p></li></ul><h4 id="（3）Sources选项"><a href="#（3）Sources选项" class="headerlink" title="（3）Sources选项"></a>（3）Sources选项</h4><ul><li>Sources：源代码存放的文件，蓝色。</li><li>Tests：设置测试代码存放的文件件，绿色。</li><li>Resources：一般对应着Sources文件，一般放配置文件，如：db.properties。</li><li>Test Resources：这个对应着Tests文件夹，存放着Tests代码的配置文件。</li><li>Excluded：设置配出编译检查的文件，例如我们在project模块设置的out文件夹。</li></ul><h4 id="（4）Paths"><a href="#（4）Paths" class="headerlink" title="（4）Paths"></a>（4）Paths</h4><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/178495/23/9268/192020/60c8536aE1ab7cf45/26a2dc46e78b7af1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><ul><li><p>Compiler output：编译输出路径。</p></li><li><p>Inherit project compile output path：继承项目编译输出路径 选择此选项以使用为项目指定的路<br>径。即上面在Project选项中设置的out文件路径。</p></li><li><p>Use module compile output path:使用模块编译输出路径。</p><p>  Output path：编译输出路径。</p><p>  Test output path：测试代码编译输出路径。</p><p>  Exclude output paths： 排除输出路径，选中此复选框可以排除输出目录。</p></li><li><p>JavaDoc：使用可用控件组合与模块关联的外部JavaDocs存储位置的列表。</p></li><li><p>External Annotations：外部注释。使用 和 管理与模块关联的外部注释的位置（目录）列<br>表。</p></li></ul><h4 id="（5）Dependencies"><a href="#（5）Dependencies" class="headerlink" title="（5）Dependencies"></a>（5）Dependencies</h4><p>在此选项卡上，您可以定义模块SDK并形成模块依赖关系列表。</p><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/184112/34/9034/86034/60c853f3E8d7dc824/2117ba0c2f3987fb.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><ul><li>Module SDK：模块SDK，选择模块SDK。<br>  （要将项目SDK与模块相关联，请选择Project SDK。请注意，如果稍后更改了项目SDK，模块SDK<br>  将相应更改。<br>  如果所需SDK不在列表中，请单击“ 新建”，然后选择所需的SDK类型。然后，在打开的对话框中，<br>  选择SDK主目录，然后单击确定。<br>  要查看或编辑所选SDK的名称和内容，请单击编辑。（SDK页面将打开。）</li><li>依赖列表</li><li>相关性存储格式，选择用于存储依赖关系的格式（作为IntelliJ IDEA模块或Eclipse项目）。该选项<br>对使用不同开发工具的团队有帮助。</li></ul><h4 id="（6）Libraries"><a href="#（6）Libraries" class="headerlink" title="（6）Libraries"></a>（6）Libraries</h4><p>在此选项卡上，您可以定义模块SDK并形成模块依赖关系列表。<br>首先，可以创建一个新的项目库，可以设置分类。</p><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/186804/30/8635/62102/60c9dbfcE4a598cdd/b0657acb513baad1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><p>可以添加本地jar包，网络来源的jar包，删除jar包。</p><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/172875/13/15046/109157/60c9dc60E37b37473/b737611cf3faf2b6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><h4 id="（7）Facets"><a href="#（7）Facets" class="headerlink" title="（7）Facets"></a>（7）Facets</h4><p>表示这个 module 有什么特征，比如 Web，Spring 和 Hibernate 等；</p><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/183571/10/9259/183782/60c9de87E32b97c1c/c51115f1d4fae881.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><h4 id="（8）Artifacts"><a href="#（8）Artifacts" class="headerlink" title="（8）Artifacts"></a>（8）Artifacts</h4><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185546/29/9398/159522/60c9df17E547687cc/0f7b9a163fa469b1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><ul><li>Artifact 是 maven 中的一个概念，表示某个 module 要如何打包，例如 war exploded、war、<br>jar 等等这种打包形式；</li><li>一个 module 有了 Artifacts 就可以部署到应用服务器中了！</li><li>在给项目配置 Artifacts 的时候有好多个 type 的选项，exploed 是什么意思？explode 在这里你可<br>以理解为展开，不压缩的意思。也就是 war、jar 等产出物没压缩前的目录结构。</li><li>建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。</li><li>默认情况下，IDEA 的 Modules 和 Artifacts 的 output 目录 已经设置好了，不需要更改.</li><li>打成 war 包 的时候会自动在 WEB-INF 目录 下生产 classes 目录 ，然后把编译后的文件放进去。</li></ul><h4 id="（9）SDKS"><a href="#（9）SDKS" class="headerlink" title="（9）SDKS"></a>（9）SDKS</h4><p>系统开发工具 ，全局 SDK 配置 。</p><h4 id="（10）Global-libraries"><a href="#（10）Global-libraries" class="headerlink" title="（10）Global libraries"></a>（10）Global libraries</h4><p>全局类库，可以配置一些常用的类库。</p><h4 id="（11）Problems"><a href="#（11）Problems" class="headerlink" title="（11）Problems"></a>（11）Problems</h4><p>问题，在项目异常的时候很有用，可以根据提示进行项目修复<br>（FIXED）。</p><h4 id="（12）-idea和-iml"><a href="#（12）-idea和-iml" class="headerlink" title="（12）.idea和.iml"></a>（12）.idea和.iml</h4><blockquote><p>我们设置了半天看看我们设置的信息被保存在了哪里？</p></blockquote><p>xinzhi-shop.iml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span> <span class="attr">type</span>=<span class="string">&quot;JAVA_MODULE&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;FacetManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">facet</span> <span class="attr">type</span>=<span class="string">&quot;web&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Web&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">deploymentDescriptor</span> <span class="attr">name</span>=<span class="string">&quot;web.xml&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/WebContent/WEB-INF/web.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">webroots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/WebContent&quot;</span> <span class="attr">relative</span>=<span class="string">&quot;/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">webroots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">facet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;NewModuleRootManager&quot;</span> <span class="attr">inherit-compiler-output</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude-output</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/src&quot;</span> <span class="attr">isTestSource</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;inheritedJdk&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;sourceFolder&quot;</span> <span class="attr">forTests</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lib&quot;</span> <span class="attr">level</span>=<span class="string">&quot;project&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/176647/7/15097/288630/60c9df36E3fd364ac/81586918e1039e91.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><blockquote><p>这样别的idea打开项目时就能读取出来，并能明确项目的构建信息</p></blockquote><blockquote><p>问，eclipse直接打开能用吗？</p></blockquote><p>提问现在给你一个java工程的代码你们构建出来了吗？</p><p>或者给你一个eclipse的代码你能转化过来吗？</p><h2 id="二、Maven概述"><a href="#二、Maven概述" class="headerlink" title="二、Maven概述"></a>二、Maven概述</h2><p>以上的工作，需要我们自行构建，而且idea和eclipse，甚至一些其他的开发工具构建的时候是不一样<br>的。</p><p>那么有没有一种统一的方式，甚至无需手动点击，通过配置就可以了，通过使用命令就能就行构建呢？</p><p>当然我们看到了我们的idea其实也是通过之文件来记录构建信息的，那么既然构建如此重要，形成一套<br>规范化的，统一的便捷的构建工具就势在必行，于是出现了 maven ，当然还有 gradle ，他们的功能异<br>常强大。</p><blockquote><p>这样有什么好处</p></blockquote><ul><li>统一管理jar包，自动导入jar及其依赖，这样是很初学者唯一能感受出来的好处，确实牛逼啊。</li><li>项目移植之后甚至不需要安装开发工具，只需要maven加命令就能跑起来，降低学习成本。</li><li>使我们的项目流水线成为可能，因为使用简单的命令我们就能完成项目的编译，打包，发布等工<br>作，就让程序操作程序成为了可能，大名鼎鼎的jekins技能做到这一点。</li></ul><h3 id="1、Maven下载安装"><a href="#1、Maven下载安装" class="headerlink" title="1、Maven下载安装"></a>1、Maven下载安装</h3><p>下载地址：<a href="http://maven.apache.org/">http://maven.apache.org/</a></p><blockquote><p>小知识点： 作为一个java程序员 apache 网站的规律得知道都是 项目名.apache.org</p></blockquote><ul><li><a href="http://maven.apache.org/">http://maven.apache.org/</a></li><li><a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></li><li><a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a></li><li><a href="http://hadoop.apache.org/">http://hadoop.apache.org/</a></li></ul><p>Apache软件基金会（也就是Apache Software Foundation，简称为ASF），是专门为支持开源软件项<br>目而办的一个非盈利性组织。在它所支持的Apache项目与子项目中，所发行的软件产品都遵循Apache<br>许可证（Apache License）。</p><blockquote><p>安装以及配置环境变量，学过点java的都会</p></blockquote><ol><li>解压</li><li>配置MAVEN_HOME</li><li>配置path，%MAVEN_HOME%\bin</li><li>cmd执行 mvn -v ，出现以下界面，成功</li></ol><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/175929/34/15083/107449/60c9dfa7Ef512a20b/2e83154ad707b3b4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><h3 id="2、maven核心配置文件"><a href="#2、maven核心配置文件" class="headerlink" title="2、maven核心配置文件"></a>2、maven核心配置文件</h3><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/172048/19/15120/47817/60c9dfc4Ef70ff350/89b8441837ff7c09.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><blockquote><p>先照着配置</p></blockquote><p>（1）配置路径</p><blockquote><p>先建立好这个文件夹</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）配置阿里云镜像</p><blockquote><p>要不啥也下不动</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）配置全局编译jdk版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、常常鲜，体验"><a href="#3、常常鲜，体验" class="headerlink" title="3、常常鲜，体验"></a>3、常常鲜，体验</h3><blockquote><p>maven标准目录</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">|--main</span><br><span class="line">|--java 源代码目录</span><br><span class="line">|--resources 资源目录</span><br><span class="line">|--test</span><br><span class="line">|--java 测试代码目录</span><br><span class="line">|--resources 测试资源目录</span><br><span class="line">|--target</span><br><span class="line">|--classes 编译后的class文件目录</span><br><span class="line">|--test-classes 编译后的测试class文件目录</span><br><span class="line">pom.xml Maven工程配置文件</span><br></pre></td></tr></table></figure><p>这是大部分Maven工程的目录结构，在这个基础上可以合理地增删目录。<br>pom.xml的基本要求：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xinzhi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写个Hello.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello maven!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以再 resources 文件夹下新建 db.properties 配置文件，或随便帮一个文件;</p><p>执行，以下命令，可能会从网上下载内容，是在下载插件，不要担心。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure><p>结果，并生成target目录</p><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/189169/18/8381/291846/60c9e083E4dc710ce/238b1346fe7bc5a9.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><blockquote><p>结果发现我们编译的class文件和resources中的配置文件都放在了一起</p></blockquote><p>执行 mvn package</p><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/187217/3/8630/179442/60c9e0a8E3500a666/789be9a132b88864.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><p>观察target中已经有了我们打包好的jar包</p><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/172260/25/14578/36916/60c9e0e5Ee5a036c7/a15f66136f948f97.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><p>观察名字是不是我们项目的名字加版本号，当然此jar包无法运行，应为maven也不知道你的main方法<br>在哪里，咱们后边讲。</p><h3 id="4、Maven生命周期"><a href="#4、Maven生命周期" class="headerlink" title="4、Maven生命周期"></a>4、Maven生命周期</h3><blockquote><p>maven生命周期其实就是描述了一个项目从源代码到部署的整个周期</p></blockquote><p>Maven有三个内置的生命周期：默认（default），清洁（clean）和站点（site）。</p><ul><li>清洁（clean） 为执行以下工作做必要的清理。就是我们经常做的，删除target文件夹。</li><li>默认（default） 真正进行项目编译打包等工作的阶段</li><li>站点（site） 生成项目报告，站点，发布站点</li></ul><blockquote><p>默认（default）的生命周期包括以下阶段（该阶段经过简化，实际上更加复杂）：</p></blockquote><ol><li>验证（validate） - 验证项目是否正确，所有必要的信息可用。</li><li>编译（compile） - 编译项目的源代码。</li><li>测试（test） - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包<br>或部署。</li><li>打包（package）- 采用编译的代码，并以其可分配格式（如JAR）进行打包。</li><li>验证（verify） - 对集成测试的结果执行任何检查，以确保满足质量标准。</li><li>安装（install） - 将软件包安装到本地存储库中，用作本地其他项目的依赖项。</li><li>部署（deploy） - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享<br>（私服）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>此命令在执行安装之前按顺序（验证（validate），编译（compile），打包（package）等）执行每个<br>默认生命周期阶段。在这种情况下，您只需要调用最后一个构建阶段来执行，安装（install）。<br>在构建环境中，使用以下调用将工件清理地构建并部署到共享存储库中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean deploy</span><br></pre></td></tr></table></figure><p>相同的命令可以在多模块场景（即具有一个或多个子项目的项目）中使用。Maven遍历每个子项目并执<br>行清洁（clean），然后执行部署（deploy）（包括所有之前的构建阶段步骤）。<br>注意：在我们开发阶段，有一些生命周期的阶段，比如验证（validate）这些，基本很少用到。只要使<br>用关键的几个基本能满足需求。</p><h3 id="5、Maven-常用命令"><a href="#5、Maven-常用命令" class="headerlink" title="5、Maven 常用命令"></a>5、Maven 常用命令</h3><p>下面maven比较常见的一些命令。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>mvn –version</td><td>显示版本信息</td></tr><tr><td>mvn clean</td><td>清理项目生产的临时文件,一般是模块下的target目录</td></tr><tr><td>mvn compile</td><td>编译源代码，一般编译模块下的src/main/java目录</td></tr><tr><td>mvn package</td><td>项目打包工具,会在模块下的target目录生成jar或war等文件</td></tr><tr><td>mvn test</td><td>测试命令,或执行src/test/java/下junit的测试用例</td></tr><tr><td>mvn install</td><td>将打包的jar/war文件复制到你的本地仓库中,供其他模块使用</td></tr><tr><td>mvn deploy</td><td>将打包的文件发布到远程参考,提供其他人员进行下载依赖</td></tr><tr><td>mvn site</td><td>生成项目相关信息的网站</td></tr><tr><td>mvn dependency:tree</td><td>打印出项目的整个依赖树</td></tr><tr><td>mvn archetype:generate</td><td>创建Maven的普通java项目</td></tr><tr><td>mvn tomcat:run</td><td>在tomcat容器中运行web应用</td></tr></tbody></table><h3 id="6、Maven的版本规范（我们的项目）"><a href="#6、Maven的版本规范（我们的项目）" class="headerlink" title="6、Maven的版本规范（我们的项目）"></a>6、Maven的版本规范（我们的项目）</h3><p>所有的软件都用版本</p><p>Maven使用如下几个要素来定位一个项目，因此它们又称为项目的坐标。</p><ul><li>groudId 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名开<br>头。一般对应着JAVA的包的结构，例如org.apache。</li><li>artifactId 单独项目的唯一标识符。比如我们的tomcat, commons等。不要在artifactId中包含<br>点号(.)。</li><li>version 项目的版本。</li><li>packaging 项目的类型，默认是jar，描述了项目打包后的输出。类型为jar的项目产生一个JAR文<br>件，类型为war的项目产生一个web应用。</li></ul><p>Maven在版本管理时候可以使用几个特殊的字符串 SNAPSHOT，LATEST，RELEASE。比如”1.0-<br>SNAPSHOT”。各个部分的含义和处理逻辑如下说明：</p><ul><li>SNAPSHOT 这个版本一般用于开发过程中，表示不稳定的版本。</li><li>LATEST 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个snapshot版，具<br>体看哪个时间最后。</li><li>RELEASE 指最后一个发布版。</li></ul><h3 id="7、在idea中配置maven"><a href="#7、在idea中配置maven" class="headerlink" title="7、在idea中配置maven"></a>7、在idea中配置maven</h3><p>把画红线的东西全部配置成自己的。最后一个是仓库，在你的其他盘找一个地方新建repository文<br>件夹，自己要知道，选中，如果勾选不了就选择都选override。<br>如果不选择仓库会把jar包下载至C盘的下边目录，不好维护，还占用c盘空间。当然idea和maven可能会<br>有bug。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zn\.m2\repository</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/178249/5/9621/275402/60c9e111E21a15fbe/2719439b0d733840.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><blockquote><p>两处都要配置，一个是当前项目的maven配置，一个是新建项目的maven配置。</p></blockquote><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/189502/21/8541/74318/60c9e13fE087bd534/cde43eee3af3183a.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="blockchain"></p><h2 id="三、Maven依赖（重点）"><a href="#三、Maven依赖（重点）" class="headerlink" title="三、Maven依赖（重点）"></a>三、Maven依赖（重点）</h2><hr><blockquote><p>过几天更</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python可视化爬虫</title>
      <link href="/xfrl/2020/12/01/python%20%E7%88%AC%E8%99%AB%E4%B9%8Bselenium/"/>
      <url>/xfrl/2020/12/01/python%20%E7%88%AC%E8%99%AB%E4%B9%8Bselenium/</url>
      
        <content type="html"><![CDATA[<h1 id="python可视化爬虫之selenium可视化爬虫"><a href="#python可视化爬虫之selenium可视化爬虫" class="headerlink" title="python可视化爬虫之selenium可视化爬虫"></a>python可视化爬虫之selenium可视化爬虫</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之所以把selenium爬虫称之为可视化爬虫</p><p>主要是相较于前面所提到的几种网页解析的爬虫方式</p><p>selenium爬虫主要是模拟人的点击操作</p><p>selenium驱动浏览器并进行操作的过程是可以观察到的</p><p>就类似于你在看着别人在帮你操纵你的电脑，类似于别人远程使用你的电脑</p><p>当然了，selenium也有无界面模式</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>selenium基本介绍:</p><p>selenium 是一套完整的web应用程序测试系统，</p><p>包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）<br>和测试的并行处理（Selenium Grid）。</p><p>Selenium的核心Selenium Core基于JsUnit，<br>完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。<br>selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，</p><p>爬虫中主要用来解决JavaScript渲染问题。</p><p>用python写爬虫的时候，主要用的是selenium的Webdriver</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装selenium库</span></span><br><span class="line">pip install selenium</span><br><span class="line"><span class="comment">#安装对应浏览器驱动</span></span><br><span class="line"><span class="comment"># 我们可以通过下面的方式先看看Selenium.Webdriver支持哪些浏览器</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">help</span>(webdriver))</span><br></pre></td></tr></table></figure><p>适用浏览器：<br>PACKAGE||CONTENTS<br>—|:–:|—:<br>android (package)|blackberry (package)|chrome(package)<br>common (package)|edge (package)|firefox (package)<br>ie (package)  |       opera (package)     |    phantomjs (package)<br>remote (package)  |   safari (package)    |    support (package)<br>webkitgtk (package)</p><p>#这里要说一下比较重要的PhantomJS,</p><p>#PhantomJS是一个而基于WebKit的服务端JavaScript API</p><p>#支持Web而不需要浏览器支持，</p><p>#其快速、原生支持各种Web标准：Dom处理，CSS选择器，JSON等等。</p><p>#PhantomJS可以用用于页面自动化、网络监测、网页截屏，以及无界面测试</p><blockquote><p>谷歌浏览器驱动下载地址<br>注意对应版本号，chrome地址栏输入chrome://version/ 查看自己的Chrome版本<br>我使用的是anaconda 下载好后丢入anaconda3\Scripts文件夹下就可以了<br>如果是其他ide如：pycharm、VScode但加载的还是anaconda的集成python，依然可以这么操作</p></blockquote><p>简单测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># #声明浏览器对象</span></span><br><span class="line">browser1 = webdriver.Chrome()</span><br><span class="line">browser2 = webdriver.Firefox()</span><br><span class="line"><span class="comment"># #访问页面</span></span><br><span class="line">browser1.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser1.page_source)</span><br><span class="line"><span class="comment">#关闭当前窗口</span></span><br><span class="line">browser1.close()</span><br></pre></td></tr></table></figure><h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><p>要想对页面进行操作，首先要做的是选中页面元素，<br>比较常见的八种元素定位方式，如下表所示：</p><table><thead><tr><th>定位一个元素</th><th align="center">定位多个元素</th><th>定位方式描述</th></tr></thead><tbody><tr><td>find_element_by_id</td><td align="center">find_elements_by_id</td><td>通过元素 id进行定位</td></tr><tr><td>find_element_by_name</td><td align="center">find_elements_by_name</td><td>通过元素 名称进行定位</td></tr><tr><td>find_element_by_xpath</td><td align="center">find_elements_by_xpath</td><td>通过xpath路径进行定位</td></tr><tr><td>find_element_by_link_text</td><td align="center">find_elements_by_link_text</td><td>通过完整超链接文本进行定位</td></tr><tr><td>find_element_by_partial_link_text</td><td align="center">find_elements_by_partial_link_text</td><td>通过部分超链接文本进行定位</td></tr><tr><td>find_element_by_tag_name</td><td align="center">find_elements_by_tag_name</td><td>通过标记名称进行定位</td></tr><tr><td>find_element_by_class_name</td><td align="center">find_elements_by_class_name</td><td>通过类名称进行定位</td></tr><tr><td>find_element_by_css_selector</td><td align="center">find_elements_by_css_selector</td><td>通过css选择器进行定位</td></tr></tbody></table><h2 id="页面操作"><a href="#页面操作" class="headerlink" title="页面操作"></a>页面操作</h2><p>1.表单填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到用户名输入用户名</span></span><br><span class="line">user = drive.find_element_by_name(<span class="string">&quot;LoginForm[username]&quot;</span>)</span><br><span class="line">user.send_keys(username)</span><br><span class="line"><span class="comment"># 找到密码输入密码</span></span><br><span class="line">pwd=drive.find_element_by_id(<span class="string">&quot;LoginForm_password&quot;</span>)</span><br><span class="line">pwd.send_keys(password)</span><br><span class="line"><span class="comment"># 点击登录按钮实现登录</span></span><br><span class="line">drive.find_element_by_class_name(<span class="string">&quot;login_btn&quot;</span>).click()</span><br></pre></td></tr></table></figure><p>2.窗口句柄</p><p>简单讲，句柄就是浏览器上方每一个窗口栏的唯一标识</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前窗口所有句柄</span></span><br><span class="line">handles = drive.window_handles</span><br><span class="line"><span class="comment">#通过句柄 切换到第2个标签页</span></span><br><span class="line">drive.switch_to.window(handles[<span class="number">2</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;操作完成&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#关闭当前窗口</span></span><br><span class="line">driver.close() </span><br><span class="line"><span class="comment">#通过句柄 切换到第1个标签页</span></span><br><span class="line">drive.switch_to.window(handles[<span class="number">0</span>])</span><br><span class="line">time.sleep(random.uniform(<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>3.url加载和获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#url加载</span></span><br><span class="line">drive.get(url)</span><br><span class="line"><span class="comment"># 获取当前页面url并断言</span></span><br><span class="line">currentPageUrl = driver.current_url</span><br></pre></td></tr></table></figure><p>4.cookie处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get_cookies:获取cookie信息</span><br><span class="line">add_cookie:添加cookie信息</span><br><span class="line">drive.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">cookie = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;bar&#x27;</span>&#125;</span><br><span class="line">drive.add_cookie(cookie)</span><br><span class="line">drive.get_cookies()</span><br></pre></td></tr></table></figure><h2 id="等待方式"><a href="#等待方式" class="headerlink" title="等待方式"></a>等待方式</h2><p>现在很多网站采用 Ajax技术</p><p>无法确定网页元素什么时候能被完全加载</p><p>所以网页元素的选取比较困难</p><p>此时就需要设置等待（等待网页加载完成）</p><p>selenium有两种等待方式:</p><ul><li>显式等待</li><li>隐式等待</li></ul><p>1.显式等待</p><p>显式等待是一种条件触发式等待</p><p>直到设置的某一条件达成时才会继续执行</p><p>可以设置超时时间，如果超过超时时间元素依然没被加载，就会抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line">drive = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/&#x27;</span></span><br><span class="line">drive.get(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">WebDriverWait(self.driver,<span class="number">10</span>).until(EC.presence_of_element_located(By.ID,<span class="string">&quot;LoginForm[username]&quot;</span>))  <span class="comment">#显示等待</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;%s页面未找到元素&#x27;</span>% loc)</span><br></pre></td></tr></table></figure><p>以上代码加载 ‘<a href="http://www.baidu.com/&#39;%E9%A1%B5%E9%9D%A2">http://www.baidu.com/&#39;页面</a></p><p>并定位id为”LoginForm[username]”的元素</p><p>设置超时时间10秒，webDriverWait默认会500ms检测一下元素是否存在</p><p>selenium提供了一些内置的用于显示等待的方法，</p><p>位于expected_conditions类中，详细见下表:</p><table><thead><tr><th>内置方法</th><th>功能</th></tr></thead><tbody><tr><td>title_is</td><td>判断当前页面的title是否等于预期内容</td></tr><tr><td>title_contains</td><td>判断当前页面的title是否包含预期字符串</td></tr><tr><td>presence_of_element_located</td><td>判断某个元素是否被加到了dom树里,</td></tr><tr><td>并不代表该元素一定可见</td><td></td></tr><tr><td>presence_of_all_element_located</td><td>判断是否至少有1个元素存在于dom树里</td></tr><tr><td>visibility_of_element_located</td><td>判断某个元素是否可见</td></tr><tr><td>visibility_of</td><td>判断某个元素是否可见</td></tr><tr><td>invisibility_of_element_located</td><td>判断某个元素是否不存在于dom树里或不可见</td></tr><tr><td>text_to_be_present_in_element</td><td>判断元素中的text是否包含了预期的字符串</td></tr><tr><td>text_to_be_present_in_element_value</td><td>判断元素中的value属性是否包含了预期字符</td></tr><tr><td>frame_to_be_available_and_switch_to_it</td><td>判断该frame是否可以切换进去，如果可以，返回True并切换进去，否则返回False</td></tr><tr><td>element_to_be_clickable</td><td>判断某个元素是否可见并且是enable的</td></tr><tr><td>staleness_of</td><td>等待某个元素从dom树中移除</td></tr><tr><td>element_to_be_selected</td><td>判断某个元素是否被选中了，一般用于下拉列表</td></tr><tr><td>element_located_to_be_selected</td><td>判断某个元素是否被选中了，一般用于下拉列表</td></tr><tr><td>element_selection_state_to_be</td><td>判断某个元素的选中状态是否符合预期</td></tr><tr><td>element_located_selection_state_to_be</td><td>判断某个元素的选中状态是否符合预期</td></tr><tr><td>alert_is_present</td><td>判断页面上是否存在alert框</td></tr></tbody></table><p>2.隐式等待</p><p>隐式等待是在尝试定位某个元素时，如果没能立刻发现，就等待固定时长<br>类似于socket超时，默认设置是0秒，即相当于最长等待时长</p><p>在浏览器界面直观感受是：</p><p>等待直到网页加载完成（地址栏这个地方不是× 变成如下）时继续执行，<br>网页加载超过设置等待时长才报错</p><p>使用方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">drive = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/&#x27;</span></span><br><span class="line"><span class="comment">#设置最大等待时长 10秒</span></span><br><span class="line">drive.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">drive.get(url)</span><br><span class="line">user = drive.find_element_by_name(<span class="string">&quot;LoginForm[username]&quot;</span>)</span><br></pre></td></tr></table></figure><p>3.线程休眠</p><p>time.sleep(time)是比较常用的线程休眠方式</p><p>为了避免风险，我个人比较喜欢随机休眠</p><p>time.sleep(random.uniform(4,5))</p><h2 id="扩展程序加载"><a href="#扩展程序加载" class="headerlink" title="扩展程序加载"></a>扩展程序加载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置好应用扩展</span></span><br><span class="line">chrome_options.add_extension(extension_path)</span><br><span class="line"><span class="comment">#添加下载路径</span></span><br><span class="line"><span class="comment">#download.default_directory：设置下载路径    profile.default_content_settings.popups：设置为 0 禁止弹出窗口</span></span><br><span class="line">prefs = &#123;<span class="string">&#x27;profile.default_content_settings.popups&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;download.default_directory&#x27;</span>:tmp_path&#125;</span><br><span class="line">chrome_options.add_experimental_option(<span class="string">&#x27;prefs&#x27;</span>, prefs)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫方法介绍</title>
      <link href="/xfrl/2020/11/13/python%E7%88%AC%E8%99%AB%E6%96%B9%E6%B3%95/"/>
      <url>/xfrl/2020/11/13/python%E7%88%AC%E8%99%AB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫——四种常见基础爬虫方法介绍"><a href="#Python爬虫——四种常见基础爬虫方法介绍" class="headerlink" title="Python爬虫——四种常见基础爬虫方法介绍"></a>Python爬虫——四种常见基础爬虫方法介绍</h1><h2 id="一、Urllib方法"><a href="#一、Urllib方法" class="headerlink" title="一、Urllib方法"></a>一、Urllib方法</h2><p>Urllib是python内置的HTTP请求库</p><pre><code>import urllib.request</code></pre><ul><li>#1.定位抓取的url</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&#x27;http://www.baidu.com/&#x27;</span><br></pre></td></tr></table></figure><ul><li>#2.向目标url发送请求</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=urllib.request.urlopen(url)</span><br></pre></td></tr></table></figure><ul><li>#3.读取数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data=response.read()</span><br><span class="line"><span class="comment">#print(data)  #打印出来的数据有ASCII码</span></span><br><span class="line"><span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment">#decode将相应编码格式的数据转换成字符串</span></span><br></pre></td></tr></table></figure><p>#post请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.parse</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&#x27;http://www.iqianyue.com/mypost/&#x27;</span><br></pre></td></tr></table></figure><ul><li>#构建上传的data</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postdata=urllib.parse.urlencode(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;pass&#x27;</span>:<span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;).encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#字符串转化成字节流数据</span></span><br><span class="line"></span><br><span class="line">html=urllib.request.urlopen(url,data=postdata).read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(html)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#headers针对检验头信息的反爬机制</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">headers=&#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request1=urllib.request.Request(<span class="string">&#x27;https://www.dianping.com/&#x27;</span>,headers=headers)<span class="comment">#Request类构建了一个完整的请求</span></span><br><span class="line">response1=urllib.request.urlopen(request1).read()</span><br><span class="line"><span class="built_in">print</span>(response1.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#超时设置+异常处理</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response1=urllib.request.urlopen(<span class="string">&#x27;http://www.ibeifeng.com/&#x27;</span>,timeout=<span class="number">0.01</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> a: <span class="comment">#所有异常的基类</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="二、requests方法"><a href="#二、requests方法" class="headerlink" title="二、requests方法"></a>二、requests方法</h2><ul><li><p>Requests是用python语言基于urllib编写的，采用的是Apache2 Licensed开源协议的HTTP库</p></li><li><p>urllib还是非常不方便的，而Requests它会比urllib更加方便，可以节约我们大量的工作。</p></li><li><p>requests是python实现的最简单易用的HTTP库，建议爬虫使用requests库。</p></li><li><p>默认安装好python之后，是没有安装requests模块的，需要单独通过pip安装</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#get请求</span></span><br><span class="line">r=requests.get(<span class="string">&#x27;https://www.taobao.com/&#x27;</span>)</span><br><span class="line"><span class="comment">#打印字节流数据</span></span><br><span class="line"><span class="comment"># print(r.content)</span></span><br><span class="line"><span class="comment"># print(r.content.decode(&#x27;utf-8&#x27;))  #转码</span></span><br><span class="line"><span class="built_in">print</span>(r.text)  <span class="comment">#打印文本数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="comment">#自动获取到网页编码，返回字典类型</span></span><br><span class="line"><span class="built_in">print</span>(chardet.detect(r.content))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST请求实现模拟表单登录</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#构建上传到网页的数据</span></span><br><span class="line">data=&#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pass&#x27;</span>:<span class="string">&#x27;123456&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#带登陆数据发送请求</span></span><br><span class="line">r=requests.post(<span class="string">&#x27;http://www.iqianyue.com/mypost/&#x27;</span>,data=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)   <span class="comment">#打印请求数据</span></span><br><span class="line"><span class="comment">#将登录后的html储存在本地</span></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;login.html&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(r.content)  <span class="comment">#写入字节流数据</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#针对检验头信息的反爬机制headers</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#构建headers</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">r=requests.get(<span class="string">&#x27;https://www.dianping.com/&#x27;</span>,headers=headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)   <span class="comment">#状态403 被拦截了(查看状态)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#针对检验头信息的反爬机制headers</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#构建headers</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">r=requests.get(<span class="string">&#x27;https://www.dianping.com/&#x27;</span>,headers=headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)   <span class="comment">#状态403 被拦截了(查看状态)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cookies</span></span><br><span class="line"><span class="comment">#跳过登陆，获取资源</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;cookie.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)   <span class="comment">#打开cookie文件</span></span><br><span class="line"><span class="comment">#初始化cookies，声明一个空字典</span></span><br><span class="line">cookies=&#123;&#125;</span><br><span class="line"><span class="comment">#按照字符 ； 进行切割读取，返回列表数据，然后遍历</span></span><br><span class="line"><span class="comment">#split()：切割函数   strip()去除字符串前后空白</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.read().split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">    <span class="comment">#split将参数设置为1，把字符串切割成两个部分</span></span><br><span class="line">    name,value=line.strip().split(<span class="string">&#x27;=&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#为空字典cookies添加内容</span></span><br><span class="line">    cookies[name]=value</span><br><span class="line">r=requests.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>,cookies=cookies)</span><br><span class="line">data=r.text</span><br><span class="line">f1=<span class="built_in">open</span>(<span class="string">&#x27;baidu.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f1.write(data)</span><br><span class="line">f1.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置代理（网站搜索免费代理ip）</span></span><br><span class="line"><span class="comment">#解决网页封IP的问题</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">proxies=&#123;</span><br><span class="line">    <span class="comment">#&#x27;协议&#x27;:&#x27;ip:端口号&#x27;</span></span><br><span class="line">    <span class="string">&#x27;HTTP&#x27;</span>:<span class="string">&#x27;222.83.160.37：61205&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">req=requests.get(<span class="string">&#x27;http://www.taobao.com/&#x27;</span>,proxies=proxies)</span><br><span class="line"><span class="built_in">print</span>(req.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置超时</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> Timeout</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&quot;http://www.ibeifeng.com &quot;</span>, timeout=<span class="number">0.01</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"><span class="keyword">except</span> Timeout:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;访问超时！&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="三、BS4-BeautifulSoup4解析"><a href="#三、BS4-BeautifulSoup4解析" class="headerlink" title="三、BS4- BeautifulSoup4解析"></a>三、BS4- BeautifulSoup4解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># #创建一个BS对象</span></span><br><span class="line">soup=BeautifulSoup(html,<span class="string">&#x27;html.parser&#x27;</span>) <span class="comment">#html.parser默认解析器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup))</span><br><span class="line"><span class="comment"># 结构化输出</span></span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br><span class="line"><span class="comment">#1获取标签(只能获取第一条对应的标签)</span></span><br><span class="line"><span class="built_in">print</span>(soup.p) <span class="comment">#获取p标签</span></span><br><span class="line"><span class="built_in">print</span>(soup.a) <span class="comment">#获取a标签</span></span><br><span class="line"><span class="built_in">print</span>(soup.title) <span class="comment">#获取title</span></span><br><span class="line"><span class="comment">#2获取标签内容</span></span><br><span class="line"><span class="built_in">print</span>(soup.title.string)</span><br><span class="line"><span class="built_in">print</span>(soup.a.string)</span><br><span class="line"><span class="built_in">print</span>(soup.body.string) <span class="comment">#如果标签中有多个子标签返回None</span></span><br><span class="line"><span class="built_in">print</span>(soup.head.string) <span class="comment">#如果标签中有一个子标签返回子标签里的文本</span></span><br><span class="line"><span class="comment">#3获取属性</span></span><br><span class="line"><span class="built_in">print</span>(soup.a.attrs) <span class="comment">#返回字典</span></span><br><span class="line"><span class="built_in">print</span>(soup.a[<span class="string">&#x27;id&#x27;</span>]) <span class="comment">#得到指定属性值</span></span><br><span class="line"><span class="comment">#4操作字节点</span></span><br><span class="line"><span class="built_in">print</span>(soup.p.contents) <span class="comment">#得到标签下所有子节点</span></span><br><span class="line"><span class="built_in">print</span>(soup.p.children) <span class="comment">#得到标签下所有子节点的迭代对象</span></span><br><span class="line"><span class="comment">#5操作父节点</span></span><br><span class="line"><span class="built_in">print</span>(soup.p.parent) <span class="comment">#得到标签p的父节点其内部的所有内容</span></span><br><span class="line"><span class="built_in">print</span>(soup.p.parents) <span class="comment"># 得到标签p的父节点的迭代对象</span></span><br><span class="line"><span class="comment">#6操作兄弟节点(同级的节点)</span></span><br><span class="line"><span class="comment">#next_sibling和previous_sibling分别获取节点的下一个和上一个兄弟元素</span></span><br><span class="line"><span class="built_in">print</span>(soup.a.next_sibling)</span><br><span class="line"><span class="built_in">print</span>(soup.a.previous_sibling)</span><br><span class="line"></span><br><span class="line"><span class="comment">#二.搜索文档数</span></span><br><span class="line"><span class="comment">#1标签名</span></span><br><span class="line"><span class="comment">#查询所有a标签</span></span><br><span class="line">res1=soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)</span><br><span class="line"><span class="comment">#获取所有a标签下属性为class=&quot;sister&quot;的标签（</span></span><br><span class="line"><span class="comment">#使用 class 做参数会导致语法错误，这里也要用class_）</span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>,class_=<span class="string">&quot;sister&quot;</span>))</span><br><span class="line"><span class="comment">#2正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#查询所有包含d字符的标签</span></span><br><span class="line">res2=soup.find_all(re.<span class="built_in">compile</span>(<span class="string">&#x27;d+&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br><span class="line"><span class="comment">#3列表</span></span><br><span class="line"><span class="comment">#查找所有的title标签和a标签</span></span><br><span class="line">res3=soup.find_all([<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(res3)</span><br><span class="line"><span class="comment">#4关键词</span></span><br><span class="line"><span class="comment">#查询属性id=&#x27;link1&#x27;的标签</span></span><br><span class="line">res4=soup.find_all(<span class="built_in">id</span>=<span class="string">&#x27;link1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res4)</span><br><span class="line"><span class="comment">#5内容匹配</span></span><br><span class="line">res5=soup.find_all(text=<span class="string">&#x27;Tillie&#x27;</span>)  <span class="comment">#文本匹配</span></span><br><span class="line">res55=soup.find_all(text=re.<span class="built_in">compile</span>(<span class="string">&#x27;Dormouse&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(res55)</span><br><span class="line"><span class="comment">#6嵌套选择</span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;p&#x27;</span>))</span><br><span class="line"><span class="comment">#查看所有p标签下所有的a标签</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;p&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(i.find_all(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#三.CSS选择器</span></span><br><span class="line"><span class="comment">#1根据标签查询对象</span></span><br><span class="line">res6=soup.select(<span class="string">&#x27;a&#x27;</span>) <span class="comment">#返回列表</span></span><br><span class="line"><span class="built_in">print</span>(res6) <span class="comment">#得到所有的a标签</span></span><br><span class="line"><span class="comment">#2根据ID属性查询标签对象(id用#)</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;#link2&#x27;</span>))</span><br><span class="line"><span class="comment">#3根据class属性查询标签对象(class用.)</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;.sister&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;.sister&#x27;</span>)[<span class="number">2</span>].get_text()) <span class="comment">#获取文本内容</span></span><br><span class="line"><span class="comment">#4属性选择(获取a标签里=href属性值的标签)</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>))</span><br><span class="line"><span class="comment">#5包含选择(获取)</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;p a#link1&#x27;</span>))</span><br><span class="line"><span class="comment">#6并列选择</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a#link1,a#link2&#x27;</span>))</span><br><span class="line"><span class="comment">#7得到标签内容</span></span><br><span class="line">res7=soup.select(<span class="string">&#x27;p a.sister&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res7:</span><br><span class="line">    <span class="built_in">print</span>(i.get_text())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#爬取51job主页12个职位</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;https://www.51job.com/&#x27;</span></span><br><span class="line">headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">html=requests.get(url,headers=headers)</span><br><span class="line">data=html.content.decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">soup=BeautifulSoup(data,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="comment">#获取span标签，class_=&quot;at&quot;属性</span></span><br><span class="line">span=soup.find_all(<span class="string">&#x27;span&#x27;</span>,class_=<span class="string">&quot;at&quot;</span>)</span><br><span class="line"><span class="comment"># for i in span:</span></span><br><span class="line"><span class="comment">#     print(i.get_text())</span></span><br><span class="line"><span class="comment">#select方法（CSS选择器）</span></span><br><span class="line">span1=soup.select(<span class="string">&#x27;span[class=&quot;at&quot;]&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> span1:</span><br><span class="line">    <span class="built_in">print</span>(m.get_text())</span><br></pre></td></tr></table></figure><h2 id="四、XPath语法"><a href="#四、XPath语法" class="headerlink" title="四、XPath语法"></a>四、XPath语法</h2><p>XPath 是一门在 XML 文档中查找信息的语言。</p><p>XPath 可用来在 XML 文档中对元素和属性进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> &lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">            &lt;title&gt;春晚&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;h1 name=&quot;title&quot;&gt;个人简介&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;div name=&quot;desc&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;p name=&quot;name&quot;&gt;姓名：&lt;span&gt;岳云鹏&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;p name=&quot;addr&quot;&gt;住址：中国 河南&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;p name=&quot;info&quot;&gt;代表作：五环之歌&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#初始化</span></span><br><span class="line">html=etree.HTML(text)</span><br><span class="line"><span class="comment"># result=etree.tostring(html)   #字节流</span></span><br><span class="line"><span class="comment"># print(result.decode(&#x27;utf-8&#x27;))</span></span><br><span class="line"><span class="comment">#查询所有的p标签</span></span><br><span class="line">p_x=html.xpath(<span class="string">&#x27;//p&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p_x)</span><br><span class="line"><span class="comment">#查询所有p标签的文本,用text只能拿到该标签下的文本，不包括子标签</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p_x:</span><br><span class="line">    <span class="built_in">print</span>(i.text)   <span class="comment">#发现&lt;span&gt;没有拿到</span></span><br><span class="line"><span class="comment">#优化，用string（）拿标签内部的所有文本</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p_x:</span><br><span class="line">    <span class="built_in">print</span>(i.xpath(<span class="string">&#x27;string(.)&#x27;</span>))</span><br><span class="line"><span class="comment"># 查询所有name属性的值</span></span><br><span class="line">attr_name=html.xpath(<span class="string">&#x27;//@name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(attr_name)</span><br><span class="line"><span class="comment">#查询出所有包含name属性的标签</span></span><br><span class="line">attr_name1=html.xpath(<span class="string">&#x27;//*[@name]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(attr_name1)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DFS &amp; BFS</title>
      <link href="/xfrl/2020/03/07/%E6%B7%B1%E6%90%9C%E5%B9%BF%E6%90%9C/"/>
      <url>/xfrl/2020/03/07/%E6%B7%B1%E6%90%9C%E5%B9%BF%E6%90%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS-amp-BFS-详解及-Java实现"><a href="#DFS-amp-BFS-详解及-Java实现" class="headerlink" title="DFS &amp; BFS 详解及 Java实现"></a>DFS &amp; BFS 详解及 Java实现</h1><p>BFS和DFS是图的两种遍历方式，是最简单的图搜索算法。</p><p>本文将给出给出BFS和DFS的以下几种实现方式：</p><ul><li>1、使用队列Queue实现图的BFS遍历</li><li>2、递归实现图的DFS遍历</li><li>3、使用栈Stack迭代实现图的DFS遍历</li></ul><h2 id="一、BFS（广度优先搜索算法）"><a href="#一、BFS（广度优先搜索算法）" class="headerlink" title="一、BFS（广度优先搜索算法）"></a>一、BFS（广度优先搜索算法）</h2><blockquote><p>原理：宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p></blockquote><p>&nbsp;&nbsp;BFS算法之所以叫做广度优先搜索，是因为它始终将已发现的顶点和未发现的之间的边界，沿其广度方向向外扩展。亦即，算法首先会发现和s距离为k的所有顶点，然后才会发现和s距离为k+1的其他顶点。</p><p>&nbsp;&nbsp;同深度优先搜索相反，BFS宽度优先搜索每次选择深度最浅的节点优先扩展。并且当问题有解时，宽度优先算法一定能够找到解，并且在单位耗散时间的情况下，可以保证找到最优解。</p><blockquote><p>基于邻接矩阵的BFS：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_Graph</span><span class="params">(GraphAMatrix G)</span></span>&#123;</span><br><span class="line">    <span class="comment">//图的广度优先遍历</span></span><br><span class="line">    <span class="keyword">int</span> i,j,e;<span class="comment">//i j 为循环控制变量 e为取队列元素变量</span></span><br><span class="line">    CQueue  Q;</span><br><span class="line">    <span class="keyword">int</span> *visited = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*G.numVertexes);<span class="comment">//标记数组</span></span><br><span class="line">    <span class="built_in">InitCQueue</span>(&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">        <span class="comment">//遍历所有顶点 非连通图的情况化 要遍历全部加上循环</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">EnCQueue</span>(&amp;Q,i);<span class="comment">//起点入队列</span></span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">CQueue</span>(Q))&#123;<span class="comment">//循环操作</span></span><br><span class="line">                <span class="built_in">DeQueue</span>(&amp;Q,&amp;e);<span class="comment">//出队列</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;</span><br><span class="line">                    <span class="comment">//遍历顶点集合</span></span><br><span class="line">                    <span class="keyword">if</span>(!visited[j]&amp;&amp;G.edges[e][j])&#123;</span><br><span class="line">                        <span class="comment">//判断当前结点是否被访问过 且与出队结点是否相连</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,j);</span><br><span class="line">                        visited[j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">EnCQueue</span>(&amp;Q,j); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>基于邻接表的BFS</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_GraphADJList</span><span class="params">(GraphADJList G)</span></span>&#123;</span><br><span class="line">    <span class="comment">//图的广度优先遍历</span></span><br><span class="line">    <span class="keyword">int</span> i,j,e;<span class="comment">//i j 为循环控制变量 e为取队列元素变量</span></span><br><span class="line">    CQueue  Q;</span><br><span class="line">    EdgeNode *p; </span><br><span class="line">    <span class="keyword">int</span> *visited = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*G.numVertexes);<span class="comment">//标记数组</span></span><br><span class="line">    <span class="built_in">InitCQueue</span>(&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">        <span class="comment">//遍历所有顶点 非连通图的情况化 要遍历全部加上循环</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">EnCQueue</span>(&amp;Q,i);<span class="comment">//起点入队列</span></span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">CQueue</span>(Q))&#123;<span class="comment">//循环操作</span></span><br><span class="line">                <span class="built_in">DeQueue</span>(&amp;Q,&amp;e);<span class="comment">//出队列</span></span><br><span class="line">                p = G.adjList[e].firstedge;<span class="comment">//从顶点的链表的第一个边结点开始 </span></span><br><span class="line">                <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                    j = p-&gt;adjvex;<span class="comment">//记录当前边的终点序号 </span></span><br><span class="line">                    <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,j);</span><br><span class="line">                        visited[j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">EnCQueue</span>(&amp;Q,j); </span><br><span class="line">                    &#125; </span><br><span class="line">                    p = p-&gt;next;<span class="comment">//移动到下一条边 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="二、DFS（深度优先搜索算法）"><a href="#二、DFS（深度优先搜索算法）" class="headerlink" title="二、DFS（深度优先搜索算法）"></a>二、DFS（深度优先搜索算法）</h2><blockquote><p>原理：深度优先搜索，顾名思义即为一条道走到黑的搜索策略，行不通退回来换另外一条道再走到黑，依次直到搜索完成。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p></blockquote><p>&nbsp;&nbsp;DFS算法利用递归方式实现，和BFS不同的是BFS搜索产生的始终是一棵树，而DFS产生的可能会使一个森林。</p><p>&nbsp;&nbsp;对于深度优先搜索算法的思想。在一般情况下，当问题有解时，深度优先搜索不但不能够保证找到最优解，也不能保证找到解。如果问题状态空间有限，则可以保证找到解；但是当问题的状态空间无限时，则可能陷入“深渊”而找不到解。为此我们可以利用回溯算法中的思想，可以加上对搜索的深度限制。从而实现对于搜索深度的限制。当然深度限制设置必须合理，深度过深则影响搜索的效率，深度过浅时，则可能影响找到问题的解。</p><p><strong>使用栈实现DFS思路关键点：</strong></p><p>1、首先明确整个DFS主要便是对于栈进行操作，就是在顶点压栈和弹栈过程中我们需要进行的操作；</p><p>2、利用DFS的思想，深度遍历节点。直到栈内元素为空位置；</p><p>3、何时进行压栈：对于栈顶顶点，看其邻接顶点中是够存在未被遍历过得白色顶点，若有则对将其压栈，然后再对栈顶元素进行操作；</p><p>4、如果栈顶顶点的所有邻接顶点都是被遍历过的灰色顶点，则将栈顶元素弹栈，然后再对现在的栈顶元素进行操作；</p><p>5、算法结束时，所有元素均被遍历过即为灰色，并且栈已经为空。</p><blockquote><p>基于邻接矩阵的DFS算法代码实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphAMatrix G,<span class="keyword">int</span> i,<span class="keyword">int</span> *visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(visited[i])</span><br><span class="line">        <span class="keyword">return</span> ;<span class="comment">//若结点被遍历过 返回 </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        visited[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历与该结点相邻的结点 (从第一个开始) </span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexs;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i]&amp;&amp;G.Edge[i][j])</span><br><span class="line">                <span class="built_in">DFS</span>(G,j,visited);<span class="comment">//从相邻结点的第一个进行递归式深搜遍历 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_GreahDG</span><span class="params">(GreapAMstrix G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,e;</span><br><span class="line">    <span class="keyword">int</span> *visited;<span class="comment">//为每一个结点设置一个初始标志为未遍历 </span></span><br><span class="line">    visited=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*G.numVertexs);</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*G.numVertexs);</span><br><span class="line">    <span class="comment">//对每一个未被遍历结点进行DFS深度搜索 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexs;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            <span class="built_in">DFS</span>(G,i,visited);<span class="comment">//调用深搜算法 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(visited);<span class="comment">//释放指针 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>基于邻接表的DFS算法实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxvn 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义图的存储数据类型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvesx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *firstarc; </span><br><span class="line">&#125;VNode,AdjList[maxvn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> Vnum,Anum;</span><br><span class="line">&#125;AdjGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个全局标识数组 </span></span><br><span class="line"><span class="keyword">int</span> visited[maxvn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(<span class="keyword">char</span> u,AdjGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.Vnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u==G.vertices[i].data)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==G.Vnum)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatAdjGraph_adjList</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input Vnum and Anum:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;G.Vnum&gt;&gt;G.Anum;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input Vertices:&quot;</span>&lt;&lt;endl;<span class="comment">//创建表头 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.Vnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input Arc[i][j]:&quot;</span>&lt;&lt;endl;<span class="comment">//创建链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;G.Anum;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ArcNode));</span><br><span class="line">        <span class="keyword">char</span> v1,v2;</span><br><span class="line">        cin&gt;&gt;v1&gt;&gt;v2;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="built_in">LocateVex</span>(v1,G);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="built_in">LocateVex</span>(v2,G);</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        cin&gt;&gt;w;</span><br><span class="line">        p-&gt;adjvesx=j;</span><br><span class="line">        p-&gt;info=w;</span><br><span class="line">        p-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=p; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深搜算法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AdjGraph G,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode*p;</span><br><span class="line">    visited[i]=<span class="number">1</span>;</span><br><span class="line">    p=G.vertices[i].firstarc;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;adjvesx])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[p-&gt;adjvesx]=<span class="number">1</span>;</span><br><span class="line">            cout&lt;&lt;p-&gt;adjvesx&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p=p-&gt;nextarc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用深搜算法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(AdjGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.Vnum;i++)</span><br><span class="line">        visited[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.Vnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            <span class="built_in">DFS</span>(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjGraph G;</span><br><span class="line">    <span class="built_in">CreatAdjGraph_adjList</span>(G);</span><br><span class="line">    <span class="built_in">DFSTraverse</span>(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="三、BFS和DFS实现（java）"><a href="#三、BFS和DFS实现（java）" class="headerlink" title="三、BFS和DFS实现（java）"></a>三、BFS和DFS实现（java）</h2><p>1、Vertex对象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex1</span> </span>&#123;</span><br><span class="line">    String verName;</span><br><span class="line">    String color;  </span><br><span class="line">    <span class="keyword">int</span> discoverTime;</span><br><span class="line">    <span class="keyword">int</span> finishTime;</span><br><span class="line">    Vertex1 nextNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Graph对象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph1</span> </span>&#123;</span><br><span class="line">    Vertex1[] vertexArray=<span class="keyword">new</span> Vertex1[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> verNum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> edgeNum=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、核心实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;无权有向图和无向图的构建以及实现了图的BFS遍历和DFS遍历:</span></span><br><span class="line"><span class="comment"> * 1&gt;.使用队列Queue实现图的BFS遍历;</span></span><br><span class="line"><span class="comment"> * 2&gt;.递归实现图的DFS遍历;</span></span><br><span class="line"><span class="comment"> * 3&gt;.使用栈Stack迭代实现图的DFS遍历。&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> King</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateGraph1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">    Stack&lt;Vertex1&gt; stackVertex=<span class="keyword">new</span> Stack&lt;Vertex1&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Graph1 graph=<span class="keyword">new</span> Graph1();</span><br><span class="line">        CreateGraph1 createGraph=<span class="keyword">new</span> CreateGraph1();</span><br><span class="line">        createGraph.initialGraph(graph);</span><br><span class="line">        createGraph.outputGraph(graph);</span><br><span class="line"><span class="comment">//      System.out.println(&quot;DFS搜索路径为(递归实现)：&quot;);</span></span><br><span class="line"><span class="comment">//      createGraph.DFS(graph);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;DFS搜索路径为(栈实现):&quot;</span>);</span><br><span class="line">        createGraph.stackMain(graph);</span><br><span class="line"><span class="comment">//      System.out.println(&quot;BFS搜索路径为：&quot;);</span></span><br><span class="line"><span class="comment">//      createGraph.BFS(graph);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户输入的string类型的顶点返回该顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 输入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>返回一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vertex1 <span class="title">getVertex</span><span class="params">(Graph1 graph,String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.verNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph.vertexArray[i].verName.equals(str))&#123;</span><br><span class="line">                <span class="keyword">return</span> graph.vertexArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户输入的数据初始化一个图，以邻接表的形式构建!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 生成的图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialGraph</span><span class="params">(Graph1 graph)</span></span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入顶点数和边数：&quot;</span>);</span><br><span class="line">        graph.verNum=scan.nextInt();</span><br><span class="line">        graph.edgeNum=scan.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入定点名称：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.verNum;i++)&#123;</span><br><span class="line">            Vertex1 vertex=<span class="keyword">new</span> Vertex1();</span><br><span class="line">            String name=scan.next();</span><br><span class="line">            vertex.verName=name;</span><br><span class="line">            vertex.color=<span class="string">&quot;white&quot;</span>;</span><br><span class="line">            vertex.discoverTime=<span class="number">0</span>;</span><br><span class="line">            vertex.finishTime=<span class="number">0</span>;</span><br><span class="line">            vertex.nextNode=<span class="keyword">null</span>;</span><br><span class="line">            graph.vertexArray[i]=vertex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入图的便边：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.edgeNum;i++)&#123;</span><br><span class="line">            String preV=scan.next();</span><br><span class="line">            String folV=scan.next();</span><br><span class="line"></span><br><span class="line">            Vertex1 v1=getVertex(graph,preV);</span><br><span class="line">            <span class="keyword">if</span>(v1==<span class="keyword">null</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;输入边存在图中没有的顶点！&quot;</span>);</span><br><span class="line">            Vertex1 v2=<span class="keyword">new</span> Vertex1();</span><br><span class="line">            v2.verName=folV;</span><br><span class="line">            v2.nextNode=v1.nextNode;</span><br><span class="line">            v1.nextNode=v2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//          紧接着下面注释的代码加上便是构建无向图的，不加则是构建有向图的！</span></span><br><span class="line"><span class="comment">//          Vertex1 reV2=getVertex(graph,folV);</span></span><br><span class="line"><span class="comment">//          if(reV2==null)</span></span><br><span class="line"><span class="comment">//              System.out.println(&quot;输入边存在图中没有的顶点！&quot;);</span></span><br><span class="line"><span class="comment">//          Vertex1 reV1=new Vertex1();</span></span><br><span class="line"><span class="comment">//          reV1.verName=preV;</span></span><br><span class="line"><span class="comment">//          reV1.nextNode=reV2.nextNode;</span></span><br><span class="line"><span class="comment">//          reV2.nextNode=reV1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入图的邻接表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 待输出的图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputGraph</span><span class="params">(Graph1 graph)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出图的邻接链表为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.verNum;i++)&#123;</span><br><span class="line">            Vertex1 vertex=graph.vertexArray[i];</span><br><span class="line">            System.out.print(vertex.verName);</span><br><span class="line"></span><br><span class="line">            Vertex1 current=vertex.nextNode;</span><br><span class="line">            <span class="keyword">while</span>(current!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;--&gt;&quot;</span>+current.verName);</span><br><span class="line">                current=current.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS遍历辅助函数，标记颜色是辅助，即根据顶点返回其下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>返回下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(Vertex1 vertex,Graph1 graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.verNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vertex.verName.equals(graph.vertexArray[i].verName))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS深度优先遍历初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph1 graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.verNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph.vertexArray[i].color.equals(<span class="string">&quot;white&quot;</span>))&#123;</span><br><span class="line">                DfsVisit(graph.vertexArray[i],graph);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS递归函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DfsVisit</span><span class="params">(Vertex1 vertex,Graph1 graph)</span></span>&#123;</span><br><span class="line">        vertex.color=<span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        time=time+<span class="number">1</span>;</span><br><span class="line">        vertex.discoverTime=time;</span><br><span class="line">        System.out.print(vertex.verName+<span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Vertex1 current=vertex.nextNode;</span><br><span class="line">        <span class="keyword">while</span>(current!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Vertex1 currentNow=getVertex(graph, current.verName);</span><br><span class="line">            <span class="keyword">if</span>(currentNow.color.equals(<span class="string">&quot;white&quot;</span>))</span><br><span class="line">                DfsVisit(currentNow,graph);</span><br><span class="line">            current=current.nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        vertex.color=<span class="string">&quot;black&quot;</span>;</span><br><span class="line">        time=time+<span class="number">1</span>;</span><br><span class="line">        vertex.finishTime=time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找一个节点的邻接点中是否还有白色节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回白色节点或是null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vertex1 <span class="title">getAdj</span><span class="params">(Graph1 graph,Vertex1 vertex)</span></span>&#123;</span><br><span class="line">        Vertex1 ver=getVertex(graph, vertex.verName);</span><br><span class="line">        Vertex1 current=ver.nextNode;</span><br><span class="line">        <span class="keyword">if</span>(current==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Vertex1 cur=getVertex(graph, current.verName);</span><br><span class="line">            <span class="keyword">while</span>(current!=<span class="keyword">null</span> &amp;&amp; cur.color.equals(<span class="string">&quot;gray&quot;</span>))&#123;</span><br><span class="line">                current=current.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.color.equals(<span class="string">&quot;white&quot;</span>))&#123;</span><br><span class="line">                Vertex1 currentNow=getVertex(graph, current.verName);</span><br><span class="line">                <span class="keyword">return</span> currentNow;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过栈实现dfs遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackOperator</span><span class="params">(Graph1 graph,Vertex1 vertex)</span></span>&#123;</span><br><span class="line">        vertex.color=<span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        stackVertex.push(vertex);</span><br><span class="line">        System.out.print(vertex.verName+<span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stackVertex.isEmpty())&#123;</span><br><span class="line">            Vertex1 ver=stackVertex.peek();</span><br><span class="line">            Vertex1 current=getAdj(graph,ver);</span><br><span class="line">            <span class="keyword">if</span>(current!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stackVertex.push(current);</span><br><span class="line">                current.color=<span class="string">&quot;gray&quot;</span>;</span><br><span class="line">                System.out.print(current.verName+<span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stackVertex.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS遍历主函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackMain</span><span class="params">(Graph1 graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.verNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph.vertexArray[i].color.equals(<span class="string">&quot;white&quot;</span>))&#123;</span><br><span class="line">                stackOperator(graph,graph.vertexArray[i]);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BFS广度优先搜索实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph1 graph)</span></span>&#123;</span><br><span class="line">        Vertex1 current=graph.vertexArray[<span class="number">0</span>];</span><br><span class="line">        current.color=<span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        time=time+<span class="number">1</span>;</span><br><span class="line">        current.discoverTime=time;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Vertex1&gt; queue=<span class="keyword">new</span> LinkedList&lt;Vertex1&gt;();</span><br><span class="line">        queue.offer(current);</span><br><span class="line">        <span class="keyword">while</span>(queue.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Vertex1 ver=queue.poll();</span><br><span class="line">            time=time+<span class="number">1</span>;</span><br><span class="line">            ver.finishTime=time;</span><br><span class="line">            System.out.print(ver.verName+<span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Vertex1 cur=ver.nextNode;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Vertex1 curNow=getVertex(graph, cur.verName);</span><br><span class="line">                <span class="keyword">if</span>(curNow.color.equals(<span class="string">&quot;white&quot;</span>))&#123;</span><br><span class="line">                    curNow.color=<span class="string">&quot;gray&quot;</span>;</span><br><span class="line">                    time=time+<span class="number">1</span>;</span><br><span class="line">                    curNow.discoverTime=time;</span><br><span class="line">                    queue.offer(curNow);</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DFS测试图的边：</span></span><br><span class="line"><span class="comment">v1 v2</span></span><br><span class="line"><span class="comment">v1 v3</span></span><br><span class="line"><span class="comment">v2 v3</span></span><br><span class="line"><span class="comment">v3 v4</span></span><br><span class="line"><span class="comment">v4 v2</span></span><br><span class="line"><span class="comment">v5 v4</span></span><br><span class="line"><span class="comment">v5 v6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">BFS测试图的边(10)：</span></span><br><span class="line"><span class="comment">v1 v2</span></span><br><span class="line"><span class="comment">v1 v4</span></span><br><span class="line"><span class="comment">v2 v3</span></span><br><span class="line"><span class="comment">v4 v5</span></span><br><span class="line"><span class="comment">v4 v8</span></span><br><span class="line"><span class="comment">v5 v6</span></span><br><span class="line"><span class="comment">v5 v7</span></span><br><span class="line"><span class="comment">v5 v8</span></span><br><span class="line"><span class="comment">v6 v7</span></span><br><span class="line"><span class="comment">v7 v8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="四、DFS与BFS比较"><a href="#四、DFS与BFS比较" class="headerlink" title="四、DFS与BFS比较"></a>四、DFS与BFS比较</h2><blockquote><p>DFS深度优先搜索，空间需求较低，不需要BFS需要一个队列保存搜索过程中搜索记录；其次，深搜在搜索过程中要考虑回溯，在搜索HTML链接，爬取数据方面适用颇多；多用于解决连通性问题。</p></blockquote><blockquote><p>BFS广度优先搜索，空间需求较高，根据其搜索模式，便于求解最短路径问题，上文提到的Dijkstral和prim算法均基于其思想，因为是按层进行搜索，所以很容易求得最短路径。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/xfrl/2020/01/14/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/xfrl/2020/01/14/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>&nbsp;&nbsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>&nbsp;&nbsp;回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>&nbsp;&nbsp;许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><h2 id="2、基本思想"><a href="#2、基本思想" class="headerlink" title="2、基本思想"></a>2、基本思想</h2><p>&nbsp;&nbsp;在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p><p>&nbsp;&nbsp;若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p><p>&nbsp;&nbsp;而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><h2 id="3、用回溯法解题的一般步骤："><a href="#3、用回溯法解题的一般步骤：" class="headerlink" title="3、用回溯法解题的一般步骤："></a>3、用回溯法解题的一般步骤：</h2><p>（1）针对所给问题，确定问题的解空间：<br>首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p><p>（2）确定结点的扩展搜索规则</p><p>（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p><h2 id="4、算法框架"><a href="#4、算法框架" class="headerlink" title="4、算法框架"></a>4、算法框架</h2><p>（1）问题框架</p><p>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,……,n)之间满足某种条件，记为f(ai)。</p><p>（2）非递归回溯框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">int</span> a[n],i;</span><br><span class="line"> <span class="number">2</span>: 初始化数组a[];</span><br><span class="line"> <span class="number">3</span>: i = <span class="number">1</span>;</span><br><span class="line"> <span class="number">4</span>: <span class="keyword">while</span> (i&gt;<span class="number">0</span>(有路可走)   <span class="built_in"><span class="keyword">and</span></span>  (未达到目标))  <span class="comment">// 还未回溯到头</span></span><br><span class="line"> <span class="number">5</span>: &#123;</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">if</span>(i &gt; n)                                              <span class="comment">// 搜索到叶结点</span></span><br><span class="line"> <span class="number">7</span>:     &#123;   </span><br><span class="line"> <span class="number">8</span>:           搜索到一个解，输出；</span><br><span class="line"> <span class="number">9</span>:     &#125;</span><br><span class="line"><span class="number">10</span>:     <span class="keyword">else</span>                                                   <span class="comment">// 处理第i个元素</span></span><br><span class="line"><span class="number">11</span>:     &#123; </span><br><span class="line"><span class="number">12</span>:           a[i]第一个可能的值；</span><br><span class="line"><span class="number">13</span>:           <span class="keyword">while</span>(a[i]在不满足约束条件且在搜索空间内)</span><br><span class="line"><span class="number">14</span>:           &#123;</span><br><span class="line"><span class="number">15</span>:               a[i]下一个可能的值；</span><br><span class="line"><span class="number">16</span>:           &#125;</span><br><span class="line"><span class="number">17</span>:           <span class="keyword">if</span>(a[i]在搜索空间内)</span><br><span class="line"><span class="number">18</span>:          &#123;</span><br><span class="line"><span class="number">19</span>:               标识占用的资源；</span><br><span class="line"><span class="number">20</span>:               i = i+<span class="number">1</span>;                              <span class="comment">// 扩展下一个结点</span></span><br><span class="line"><span class="number">21</span>:          &#125;</span><br><span class="line"><span class="number">22</span>:          <span class="keyword">else</span> </span><br><span class="line"><span class="number">23</span>:         &#123;</span><br><span class="line"><span class="number">24</span>:               清理所占的状态空间；            <span class="comment">// 回溯</span></span><br><span class="line"><span class="number">25</span>:               i = i –<span class="number">1</span>; </span><br><span class="line"><span class="number">26</span>:          &#125;</span><br><span class="line"><span class="number">27</span>: &#125;</span><br></pre></td></tr></table></figure><p>（3）递归的算法框架</p><p>回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="number">2</span>: <span class="built_in"><span class="keyword">try</span></span>(<span class="keyword">int</span> i)</span><br><span class="line"> <span class="number">3</span>: &#123;</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span>(i&gt;n)</span><br><span class="line"> <span class="number">5</span>:        输出结果;</span><br><span class="line"> <span class="number">6</span>:      <span class="keyword">else</span></span><br><span class="line"> <span class="number">7</span>:     &#123;</span><br><span class="line"> <span class="number">8</span>:        <span class="keyword">for</span>(j = 下界; j &lt;= 上界; j=j+<span class="number">1</span>)  <span class="comment">// 枚举i所有可能的路径</span></span><br><span class="line"> <span class="number">9</span>:        &#123;</span><br><span class="line"><span class="number">10</span>:            <span class="keyword">if</span>(<span class="built_in">fun</span>(j))                 <span class="comment">// 满足限界函数和约束条件</span></span><br><span class="line"><span class="number">11</span>:              &#123;</span><br><span class="line"><span class="number">12</span>:                 a[i] = j;</span><br><span class="line"><span class="number">13</span>:               ...                         <span class="comment">// 其他操作</span></span><br><span class="line"><span class="number">14</span>:                 <span class="built_in"><span class="keyword">try</span></span>(i+<span class="number">1</span>);</span><br><span class="line"><span class="number">15</span>:               回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line"><span class="number">16</span>:               &#125;</span><br><span class="line"><span class="number">17</span>:          &#125;</span><br><span class="line"><span class="number">18</span>:      &#125;</span><br><span class="line"><span class="number">19</span>: &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/xfrl/2020/01/13/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/xfrl/2020/01/13/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h2><p>&nbsp;&nbsp;所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p><p>&nbsp;&nbsp;贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p><h2 id="二、贪心算法的基本思路："><a href="#二、贪心算法的基本思路：" class="headerlink" title="二、贪心算法的基本思路："></a>二、贪心算法的基本思路：</h2><ul><li><p>1.建立数学模型来描述问题。</p></li><li><p>2.把求解的问题分成若干个子问题。</p></li><li><p>3.对每一子问题求解，得到子问题的局部最优解。</p></li><li><p>4.把子问题的解局部最优解合成原来解问题的一个解。</p></li></ul><h2 id="三、贪心算法适用的问题"><a href="#三、贪心算法适用的问题" class="headerlink" title="三、贪心算法适用的问题"></a>三、贪心算法适用的问题</h2><p>&nbsp;&nbsp;贪心策略适用的前提是：局部最优策略能导致产生全局最优解。<br>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p><h2 id="四、贪心算法的实现框架"><a href="#四、贪心算法的实现框架" class="headerlink" title="四、贪心算法的实现框架"></a>四、贪心算法的实现框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从问题的某一初始解出发；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> （能朝给定总目标前进一步）</span><br><span class="line">&#123;</span><br><span class="line">    利用可行的决策，求出可行解的一个解元素；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">由所有解元素组合成问题的一个可行解；</span><br></pre></td></tr></table></figure><h2 id="五、贪心策略的选择"><a href="#五、贪心策略的选择" class="headerlink" title="五、贪心策略的选择"></a>五、贪心策略的选择</h2><p>&nbsp;&nbsp;因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p><h2 id="六、例题分析"><a href="#六、例题分析" class="headerlink" title="六、例题分析"></a>六、例题分析</h2><p>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p><p>[背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。</p><p>要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p><p>物品 A B C D E F G</p><p>重量 35 30 60 50 40 10 25</p><p>价值 10 40 30 50 35 40 30</p><p>分析：</p><p>目标函数： ∑pi最大</p><p>约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)</p><ul><li>（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</li><li>（2）每次挑选所占重量最小的物品装入是否能得到最优解？</li><li>（3）每次选取单位重量价值最大的物品，成为解本题的策略。<br>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</li></ul><p>贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。</p><p>可惜的是，它需要证明后才能真正运用到题目的算法中。</p><p>一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</p><p>对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：</p><p>（1）贪心策略：选取价值最大者。反例：</p><p>W=30<br>物品：A B C<br>重量：28 12 12<br>价值：30 20 20<br>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。</p><p>（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</p><p>（3）贪心策略：选取单位重量价值最大的物品。反例：</p><p>W=30<br>物品：A B C<br>重量：28 20 10<br>价值：28 20 10<br>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分治算法</title>
      <link href="/xfrl/2020/01/10/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
      <url>/xfrl/2020/01/10/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>&nbsp;&nbsp;在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p><h2 id="二、基本思想及策略"><a href="#二、基本思想及策略" class="headerlink" title="二、基本思想及策略"></a>二、基本思想及策略</h2><p>&nbsp;&nbsp;分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。<br>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p>&nbsp;&nbsp;如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h2 id="三、分治法适用的情况"><a href="#三、分治法适用的情况" class="headerlink" title="三、分治法适用的情况"></a>三、分治法适用的情况</h2><p>分治法所能解决的问题一般具有以下几个特征：</p><ul><li><p>该问题的规模缩小到一定的程度就可以容易地解决</p></li><li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p></li><li><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p></li><li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p></li></ul><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p><p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；</p><p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p><p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p><h2 id="四、分治法的基本步骤"><a href="#四、分治法的基本步骤" class="headerlink" title="四、分治法的基本步骤"></a>四、分治法的基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p><ul><li><p>step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p></li><li><p>step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题;</p></li><li><p>step3 合并：将各个子问题的解合并为原问题的解。<br>它的一般的算法设计模式如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Divide-<span class="keyword">and</span>-<span class="built_in">Conquer</span>(P)</span><br><span class="line"><span class="number">1.</span> <span class="keyword">if</span> |P|≤n0</span><br><span class="line"><span class="number">2.</span> <span class="function">then <span class="title">return</span><span class="params">(ADHOC(P))</span></span></span><br><span class="line"><span class="function">3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk</span></span><br><span class="line"><span class="function">4. <span class="keyword">for</span> i←1 to k</span></span><br><span class="line"><span class="function">5. <span class="keyword">do</span> yi ← Divide-<span class="keyword">and</span>-<span class="title">Conquer</span><span class="params">(Pi)</span> △ 递归解决Pi</span></span><br><span class="line"><span class="function">6. T ← <span class="title">MERGE</span><span class="params">(y1,y2,...,yk)</span> △ 合并子问题</span></span><br><span class="line"><span class="function">7. <span class="title">return</span><span class="params">(T)</span></span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC§是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC§求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1,P2<br>,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p><h2 id="五、分治法的复杂性分析"><a href="#五、分治法的复杂性分析" class="headerlink" title="五、分治法的复杂性分析"></a>五、分治法的复杂性分析</h2><p>&nbsp;&nbsp;一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：<br>T（n）= k T(n/m)+f(n) 通过迭代法求得方程的解：<br>递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当<br>mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。</p><p>六、可使用分治法求解的一些经典问题</p><ul><li>二分搜索</li><li>大整数乘法</li><li>Strassen矩阵乘法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li>汉诺塔</li></ul><p>七、依据分治法设计程序时的思维过程</p><p>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p><ul><li>1、一定是先找到最小问题规模时的求解方法</li><li>2、然后考虑随着问题规模增大时的求解方法</li><li>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/xfrl/2020/01/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/xfrl/2020/01/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>&nbsp;&nbsp;动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><h2 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h2><p>&nbsp;&nbsp;基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>&nbsp;&nbsp;由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><p>&nbsp;&nbsp;与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p><h2 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p><ul><li><p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p></li><li><p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p></li><li><p>(3)有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p></li></ul><h2 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h2><p>&nbsp;&nbsp;动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><p>&nbsp;&nbsp;初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p><p>(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p><p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><ul><li><p>（1）分析最优解的性质，并刻画其结构特征。</p></li><li><p>（2）递归的定义最优解。</p></li><li><p>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p></li><li><p>（4）根据计算最优值时得到的信息，构造问题的最优解</p></li></ul><h2 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h2><p>&nbsp;&nbsp;动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><ul><li><p>（1）问题的阶段</p></li><li><p>（2）每个阶段的状态</p></li><li><p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p></li></ul><p>&nbsp;&nbsp;递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>&nbsp;&nbsp;确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n,m)=max&#123;f(n-1,m), f(n-1,m-w[n])+P(n,m)&#125;</span><br></pre></td></tr></table></figure><p>六、动态规划算法基本框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=<span class="built_in">f</span>(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;<span class="built_in">g</span>(xi<span class="number">-1</span>[j1:j2]), ......, <span class="built_in">g</span>(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = <span class="built_in">g</span>(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=<span class="built_in">f</span>(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>About me</title>
      <link href="/xfrl/2019/06/19/About%20me/"/>
      <url>/xfrl/2019/06/19/About%20me/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>有些人，一旦遇见，便是一眼万年</li></ul></blockquote><blockquote><ul><li>有的心动，一旦开始，便覆水难收</li></ul></blockquote><blockquote><ul><li>飞鸟与鱼不同路，从此山海不相逢</li></ul></blockquote><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/182607/2/9588/2047442/60cb0458E07091758/487715521bd3170d.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Birds and fish do not go the same way, since then the mountains and seas do not meet"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从前</title>
      <link href="/xfrl/2019/06/07/Before/"/>
      <url>/xfrl/2019/06/07/Before/</url>
      
        <content type="html"><![CDATA[<h2 id="愿君前程似锦-再见依旧如故"><a href="#愿君前程似锦-再见依旧如故" class="headerlink" title="愿君前程似锦 再见依旧如故"></a>愿君前程似锦 再见依旧如故</h2><hr><blockquote><ul><li>记得早先少年时<br>Remember the old days</li><li>大家诚诚恳恳<br>when everyone was sincere</li><li>说一句 是一句<br>one’s word is one’s bond</li><li>清早上火车站<br>The dawn of the train station</li><li>长街黑暗无行人<br>the dark street with no sign of pedestrian</li><li>卖豆浆的小店冒着热气<br>and the steam from the soy-milk stall</li><li>从前的日色变得慢<br>The nightfalls used to come late in the past</li><li>车，马，邮件都慢<br>Everything was slow, the bike, the horse, and the post</li><li>一生只够爱一个人<br>a lifetime was all but enough to be in love with one</li><li>从前的锁也好看<br>The old-school lock was beautiful</li><li>钥匙精美有样子<br>and the key exquisite looking</li><li>你锁了 人家就懂了<br>once locked, the others understood</li></ul></blockquote><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
